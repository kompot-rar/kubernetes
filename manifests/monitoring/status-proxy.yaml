apiVersion: apps/v1
kind: Deployment
metadata:
  name: status-proxy
  namespace: monitoring
  labels:
    app: status-proxy
spec:
  replicas: 1
  selector:
    matchLabels:
      app: status-proxy
  template:
    metadata:
      labels:
        app: status-proxy
    spec:
      containers:
      - name: proxy
        image: node:18-alpine
        workingDir: /app
        command: ["sh", "-c"]
        args:
        - |
          cd /app && \
          npm init -y && \
          npm install --production --no-package-lock --no-audit --no-fund express axios cors && \
          cat <<'EOF' > index.js
          const express = require('express');
          const axios = require('axios');
          const cors = require('cors');
          const app = express();
          app.use(cors());

          const PROM_URL = "http://monitoring-kube-prometheus-prometheus.monitoring.svc:9090/api/v1/query";

          const queryProm = async (q) => {
            try {
              const res = await axios.get(PROM_URL, { params: { query: q }, timeout: 5000 });
              return res.data.data.result;
            } catch (e) {
              console.error(`Query Error (${q}):`, e.message);
              return [];
            }
          };

          app.get('/api/status', async (req, res) => {
            try {
              const [temp, pods, ram, cpu, uptime, restarts1h, unhealthyPods, argoSync] = await Promise.all([
                queryProm('max(node_hwmon_temp_celsius) by (instance)'),
                queryProm('sum(kube_pod_status_phase{phase="Running"})'),
                queryProm('100 * (1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes))'),
                queryProm('100 - (avg by (instance) (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)'),
                queryProm('time() - node_boot_time_seconds'),
                queryProm('sum(increase(kube_pod_container_status_restarts_total[1h]))'),
                queryProm('sum(kube_pod_status_phase{phase=~"Failed|Pending|Unknown"})'),
                queryProm('count(argocd_app_info{sync_status="Synced"})')
              ]);

              const nodes = temp.map((t) => {
                const instance = t.metric.instance;
                const cpuVal = cpu.find(c => c.metric.instance === instance);
                const ramVal = ram.find(r => r.metric.instance === instance);
                const upVal = uptime.find(u => u.metric.instance === instance);
                
                return {
                  name: instance.split(':')[0],
                  temp: t.value ? parseFloat(t.value[1]).toFixed(1) : "0",
                  cpu: cpuVal ? parseFloat(cpuVal.value[1]).toFixed(1) : "0",
                  ram: ramVal ? parseFloat(ramVal.value[1]).toFixed(1) : "0",
                  uptime: upVal ? (parseFloat(upVal.value[1]) / 86400).toFixed(1) : "0"
                };
              });

              // Logika "Rekruter-Ready" v2.1
              const restartCount = restarts1h[0] ? Math.round(parseFloat(restarts1h[0].value[1])) : 0;
              const unhealthyCount = unhealthyPods[0] ? parseInt(unhealthyPods[0].value[1]) : 0;
              const isSynced = argoSync[0] ? parseInt(argoSync[0].value[1]) > 0 : false;
              
              let clusterStatus = "Healthy";
              let statusMessage = isSynced ? "GitOps Synced. All systems operational." : "Cluster Operational. Manual changes detected.";
              
              if (unhealthyCount > 0) {
                clusterStatus = "Warning";
                statusMessage = `Self-healing active: ${unhealthyCount} pod(s) recovering.`;
              } else if (restartCount > 2) {
                clusterStatus = "Observed";
                statusMessage = "Recent node pressure detected. Automated recovery successful.";
              }

              res.json({
                cluster: {
                  totalPods: pods[0] ? pods[0].value[1] : "0",
                  status: clusterStatus,
                  message: statusMessage,
                  restarts1h: restartCount,
                  gitops: isSynced ? "Synced" : "Out of Sync",
                  lastUpdate: new Date().toISOString()
                },
                nodes: nodes
              });
            } catch (e) {
              res.status(502).json({ error: "Błąd serwera statusu", details: e.message });
            }
          });

          app.get('/health', (req, res) => res.send('OK'));
          app.listen(3000, () => console.log('Super-Status Proxy v2.1 (ArgoCD & Fix) listening on port 3000'));
          EOF
          node index.js
        ports:
        - containerPort: 3000
        resources:
          requests:
            cpu: 20m
            memory: 64Mi
          limits:
            cpu: 200m
            memory: 512Mi
---
apiVersion: v1
kind: Service
metadata:
  name: status-proxy
  namespace: monitoring
spec:
  selector:
    app: status-proxy
  ports:
  - port: 80
    targetPort: 3000
